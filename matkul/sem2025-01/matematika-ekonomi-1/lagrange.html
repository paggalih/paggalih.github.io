<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualisasi Lagrange 3D</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background-color: #1a1a1a; }
        #ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 320px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.85);
            border-radius: 8px;
            color: white;
            z-index: 100;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            max-height: 90vh;
            overflow-y: auto;
        }
        h2 { margin: 0 0 10px 0; font-size: 1.1rem; color: #3498db; border-bottom: 1px solid #444; padding-bottom: 5px; }
        h3 { margin: 15px 0 5px 0; font-size: 0.9rem; color: #e74c3c; border-bottom: 1px solid #444; padding-bottom: 5px; }
        label { display: block; margin-bottom: 3px; font-size: 0.8rem; color: #aaa; }
        input[type="text"], input[type="number"] {
            width: 100%;
            padding: 6px;
            margin-bottom: 8px;
            border: 1px solid #444;
            background: #222;
            color: #fff;
            border-radius: 4px;
            box-sizing: border-box;
            font-family: monospace;
        }
        select {
            width: 100%;
            padding: 6px;
            margin-bottom: 10px;
            border-radius: 4px;
            background: #333;
            color: white;
            border: 1px solid #555;
        }
        button {
            width: 100%;
            padding: 10px;
            background-color: #27ae60;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: 0.3s;
            margin-top: 10px;
        }
        button:hover { background-color: #219150; }
        .error-msg { color: #e74c3c; font-size: 0.8rem; margin-top: 5px; display: none; }
        .legend { font-size: 0.75rem; margin-top: 10px; line-height: 1.4; }
        .legend-item { display: flex; align-items: center; margin-bottom: 2px; }
        .color-box { width: 10px; height: 10px; margin-right: 8px; display: inline-block; }
        .controls-hint {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.5);
            pointer-events: none;
            font-size: 0.8rem;
        }
    </style>
</head>
<body>

    <div id="ui-container">
        <h2>1. Fungsi Tujuan (Objektif)</h2>
        <label>Preset Contoh:</label>
        <select id="exampleSelect" onchange="loadExample()">
            <option value="">-- Pilih Kasus --</option>
            <option value="utl">Utilitas Cobb-Douglas</option>
            <option value="circle">Lingkaran Maksimum</option>
            <option value="saddle">Saddle Point</option>
        </select>

        <label>f(x,y) = z</label>
        <input type="text" id="funcInput" value="x * y" placeholder="Contoh: x * y">

        <h3>2. Fungsi Kendala (Constraint)</h3>
        <label>g(x,y)</label>
        <input type="text" id="constInput" value="2*x + 2*y" placeholder="Contoh: 2*x + y">
        
        <label>Target (c)</label>
        <input type="number" id="constValInput" value="10" step="1">

        <button onclick="plotUserFunction()">Visualisasikan Lagrange</button>
        <div id="errorMsg" class="error-msg">Sintaks error! Cek rumus Anda.</div>

        <div class="legend">
            <div class="legend-item"><span class="color-box" style="background:#00bcd4"></span> Permukaan f(x,y)</div>
            <div class="legend-item"><span class="color-box" style="background:#ff0000"></span> Garis Kendala (di Permukaan)</div>
            <div class="legend-item"><span class="color-box" style="background:#ffff00"></span> Bayangan Kendala (di Lantai)</div>
        </div>
    </div>

    <div class="controls-hint">
        Klik Kiri: Putar | Scroll: Zoom | Klik Kanan: Geser
    </div>

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/9.4.4/math.min.js"></script>

    <script>
        let scene, camera, renderer, controls;
        let mainGroup; // Grup untuk menampung mesh dan garis agar rotasi sinkron
        
        // Konfigurasi Grid
        const RANGE = 10; // -5 sampai 5
        const SEGMENTS = 100; // Resolusi grid lebih tinggi agar garis kendala halus

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            // Kamera sedikit lebih jauh
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(15, 12, 15);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // Pencahayaan
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);

            // Helpers
            const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
            scene.add(gridHelper);
            
            const axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);

            // Wadah utama objek
            mainGroup = new THREE.Group();
            // Rotasi -90 derajat di X agar sumbu Z (tinggi) mengarah ke atas di Three.js
            mainGroup.rotation.x = -Math.PI / 2;
            scene.add(mainGroup);

            plotUserFunction();

            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        function loadExample() {
            const select = document.getElementById('exampleSelect');
            const fInput = document.getElementById('funcInput');
            const gInput = document.getElementById('constInput');
            const cInput = document.getElementById('constValInput');

            if(select.value === 'utl') {
                fInput.value = "x * y";
                gInput.value = "x + y";
                cInput.value = "6";
            } else if (select.value === 'circle') {
                fInput.value = "x + y";
                gInput.value = "x^2 + y^2";
                cInput.value = "16";
            } else if (select.value === 'saddle') {
                fInput.value = "y^2 - x^2";
                gInput.value = "x^2 + y^2";
                cInput.value = "9";
            }
            plotUserFunction();
        }

        function plotUserFunction() {
            const fStr = document.getElementById('funcInput').value;
            const gStr = document.getElementById('constInput').value;
            const cVal = parseFloat(document.getElementById('constValInput').value);
            const errorMsg = document.getElementById('errorMsg');
            
            let fFunc, gFunc;

            try {
                fFunc = math.compile(fStr);
                gFunc = math.compile(gStr);
                errorMsg.style.display = 'none';
            } catch (err) {
                errorMsg.style.display = 'block';
                return;
            }

            // Bersihkan objek lama
            while(mainGroup.children.length > 0){ 
                const obj = mainGroup.children[0];
                if(obj.geometry) obj.geometry.dispose();
                if(obj.material) obj.material.dispose();
                mainGroup.remove(obj); 
            }

            // --- 1. MEMBUAT PERMUKAAN (SURFACE) ---
            const geometry = new THREE.PlaneGeometry(RANGE, RANGE, SEGMENTS, SEGMENTS);
            const count = geometry.attributes.position.count;
            const positions = geometry.attributes.position.array;
            
            let minZ = Infinity;

            for (let i = 0; i < count; i++) {
                const x = positions[i * 3];
                const y = positions[i * 3 + 1]; 
                
                let z = 0;
                try {
                    z = fFunc.evaluate({ x: x, y: y });
                    // Clamp nilai ekstrem untuk visualisasi
                    if (z > 15) z = 15;
                    if (z < -15) z = -15;
                    if (isNaN(z)) z = 0;
                } catch (e) { z = 0; }

                // Skala Z agar tidak terlalu curam
                const zScaled = z * 0.5; 
                positions[i * 3 + 2] = zScaled;

                if (zScaled < minZ) minZ = zScaled;
            }

            geometry.computeVertexNormals();

            const material = new THREE.MeshStandardMaterial({ 
                color: 0x00bcd4, 
                side: THREE.DoubleSide,
                metalness: 0.2,
                roughness: 0.3,
                transparent: true,
                opacity: 0.8
            });

            const mesh = new THREE.Mesh(geometry, material);
            mainGroup.add(mesh);

            // Wireframe halus
            const wireMesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true, transparent: true, opacity: 0.1 }));
            mainGroup.add(wireMesh);


            // --- 2. MEMBUAT GARIS KENDALA (CONTOURING) ---
            // Kita akan mencari segmen garis di mana g(x,y) â‰ˆ c
            
            const constraintPointsSurface = []; // Garis merah (di permukaan)
            const constraintPointsFloor = [];   // Garis kuning (di lantai/xoy)
            
            // Parameter grid manual untuk contouring
            const step = RANGE / SEGMENTS;
            const start = -RANGE / 2;

            // Helper function untuk interpolasi linear
            function getIsoPoint(val1, val2, pos1, pos2, target) {
                const t = (target - val1) / (val2 - val1);
                return pos1 + t * (pos2 - pos1);
            }

            // Iterasi setiap sel grid untuk mencari perpotongan kontur
            for (let i = 0; i < SEGMENTS; i++) {
                for (let j = 0; j < SEGMENTS; j++) {
                    const x = start + i * step;
                    const y = start + j * step;
                    
                    // Kita cek kotak kecil (cell)
                    // P1(x,y) --- P2(x+s, y)
                    //   |            |
                    // P3(x,y+s) - P4(x+s, y+s)
                    
                    const val1 = gFunc.evaluate({x: x, y: y});
                    const val2 = gFunc.evaluate({x: x + step, y: y});
                    const val3 = gFunc.evaluate({x: x, y: y + step});
                    // Kita cukup cek tepi kiri dan tepi bawah untuk efisiensi "Marching Squares" sederhana

                    // Cek Tepi Horizontal (P1 ke P2)
                    if ((val1 < cVal && val2 > cVal) || (val1 > cVal && val2 < cVal)) {
                        const lerpX = getIsoPoint(val1, val2, x, x + step, cVal);
                        const lerpY = y;
                        
                        // Hitung Z fungsi tujuan di titik ini
                        const zSurf = fFunc.evaluate({x: lerpX, y: lerpY}) * 0.5;
                        
                        constraintPointsFloor.push(lerpX, lerpY, -6); // Z=-6 agar menempel di "lantai" bawah grafik
                        constraintPointsFloor.push(lerpX, lerpY, -6); // Teknik LineSegments butuh pasangan, disini kita buat titik diskrit (kurang optimal tapi mudah)
                        // Perbaikan: untuk LineSegments agar nyambung, kita butuh algoritma lebih kompleks. 
                        // Tapi untuk visualisasi simpel, kita pakai GL_LINES (titik-titik rapat terlihat seperti garis)
                        
                        constraintPointsSurface.push(lerpX, lerpY, zSurf);
                        constraintPointsSurface.push(lerpX, lerpY, zSurf); 
                    }

                    // Cek Tepi Vertikal (P1 ke P3)
                    if ((val1 < cVal && val3 > cVal) || (val1 > cVal && val3 < cVal)) {
                        const lerpX = x;
                        const lerpY = getIsoPoint(val1, val3, y, y + step, cVal);
                        
                        const zSurf = fFunc.evaluate({x: lerpX, y: lerpY}) * 0.5;

                        constraintPointsFloor.push(lerpX, lerpY, -6);
                        constraintPointsFloor.push(lerpX, lerpY, -6);

                        constraintPointsSurface.push(lerpX, lerpY, zSurf);
                        constraintPointsSurface.push(lerpX, lerpY, zSurf);
                    }
                }
            }

            // Render Garis Permukaan (Merah Tebal)
            const geomSurf = new THREE.BufferGeometry();
            geomSurf.setAttribute('position', new THREE.Float32BufferAttribute(constraintPointsSurface, 3));
            // Gunakan Points agar terlihat seperti garis putus-putus rapat, atau LineSegments
            // Karena urutan acak, LineSegments akan berantakan jika tidak di-sort. 
            // Trik: Gunakan PointsMaterial yang rapat atau kumpulkan vertex dengan benar.
            // Untuk kesederhanaan kode "single file", kita pakai Points yang ukurannya besar.
            const matSurf = new THREE.PointsMaterial({ color: 0xff0000, size: 0.15 });
            const pointsSurf = new THREE.Points(geomSurf, matSurf);
            mainGroup.add(pointsSurf);

            // Render Garis Lantai (Kuning)
            const geomFloor = new THREE.BufferGeometry();
            geomFloor.setAttribute('position', new THREE.Float32BufferAttribute(constraintPointsFloor, 3));
            const matFloor = new THREE.PointsMaterial({ color: 0xffff00, size: 0.12 });
            const pointsFloor = new THREE.Points(geomFloor, matFloor);
            mainGroup.add(pointsFloor);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
