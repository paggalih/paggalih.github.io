<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualisasi 3D: Max, Min, & Saddle Point</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background-color: #1a1a1a; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            z-index: 100;
            pointer-events: none;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            z-index: 100;
        }
        button {
            padding: 10px 20px;
            margin: 0 5px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #3498db;
            color: white;
            transition: background 0.3s;
        }
        button:hover { background-color: #2980b9; }
        button.active { background-color: #f39c12; font-weight: bold; transform: scale(1.05); }
        .legend {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            display: inline-block;
            font-size: 0.8rem;
        }
    </style>
</head>
<body>

    <div id="info">
        <div class="legend">
            <h2 id="title-text">Titik Maksimum</h2>
            <p id="desc-text">Bentuk seperti Puncak Gunung / Mangkuk Terbalik</p>
            <small>Klik & Tahan Mouse untuk Memutar | Scroll untuk Zoom</small>
        </div>
    </div>

    <div id="controls">
        <button onclick="updateGraph('max')" id="btn-max" class="active">Maksimum</button>
        <button onclick="updateGraph('min')" id="btn-min">Minimum</button>
        <button onclick="updateGraph('saddle')" id="btn-saddle">Titik Pelana (Saddle)</button>
    </div>

    <!-- Three.js Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, controls, mesh, axesHelper;

        function init() {
            // 1. Setup Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            // 2. Setup Camera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(20, 15, 20);

            // 3. Setup Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // 4. Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // 5. Lights
            const ambientLight = new THREE.AmbientLight(0x404040, 2); // Soft white light
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, 1);
            pointLight.position.set(10, 20, 10);
            scene.add(pointLight);
            
            const pointLight2 = new THREE.PointLight(0xffffff, 0.5);
            pointLight2.position.set(-10, -10, -10);
            scene.add(pointLight2);

            // 6. Helpers (Grid & Axes)
            const gridHelper = new THREE.GridHelper(30, 30, 0x444444, 0x222222);
            scene.add(gridHelper);

            axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);

            // 7. Initial Graph
            createGraph('max');

            // 8. Event Listener Resize
            window.addEventListener('resize', onWindowResize, false);
            
            // Start Animation Loop
            animate();
        }

        function createGraph(type) {
            // Remove old mesh if exists
            if (mesh) {
                scene.remove(mesh);
                mesh.geometry.dispose();
                mesh.material.dispose();
            }

            // Geometry Parameters
            const size = 10;
            const segments = 60; // Higher segments = smoother curve
            const geometry = new THREE.PlaneGeometry(size, size, segments, segments);
            
            // Material
            let color;
            if (type === 'max') color = 0xe74c3c; // Red
            else if (type === 'min') color = 0x2ecc71; // Green
            else color = 0x9b59b6; // Purple

            const material = new THREE.MeshPhongMaterial({ 
                color: color, 
                side: THREE.DoubleSide,
                wireframe: false,
                flatShading: false,
                shininess: 50
            });

            // Modify Vertices based on Function
            const count = geometry.attributes.position.count;
            const positions = geometry.attributes.position.array;

            // Formula Logic
            for (let i = 0; i < count; i++) {
                // PlaneGeometry is on XY plane by default. 
                // x is index*3, y is index*3+1, z is index*3+2
                const x = positions[i * 3];
                const y = positions[i * 3 + 1]; 
                let z = 0;

                // Koordinat dinormalisasi agar grafik tidak terlalu besar
                // Kita anggap range x dan y dari -5 sampai 5
                
                if (type === 'max') {
                    // Paraboloid Terbuka ke Bawah (z = 10 - x^2 - y^2)
                    // Scaled down: z = 5 - 0.2(x^2 + y^2)
                    z = 5 - 0.15 * (x*x + y*y); 
                } else if (type === 'min') {
                    // Paraboloid Terbuka ke Atas (z = x^2 + y^2)
                    // Scaled: z = -5 + 0.2(x^2 + y^2)
                    z = -5 + 0.15 * (x*x + y*y);
                } else if (type === 'saddle') {
                    // Hyperbolic Paraboloid (z = y^2 - x^2)
                    // Scaled: z = 0.2(y^2 - x^2)
                    z = 0.25 * (y*y - x*x);
                }

                // In Three.js usually Y is up, but PlaneGeometry is created on XY plane.
                // We will rotate the mesh later so Z becomes Up visually, 
                // OR we just map the Math-Z to Three-Z (which is depth), then rotate mesh -90deg X.
                // Let's modify the Z attribute of the plane geometry (which represents depth relative to plane face).
                positions[i * 3 + 2] = z; 
            }

            geometry.computeVertexNormals(); // Penting untuk pencahayaan yang halus
            mesh = new THREE.Mesh(geometry, material);
            
            // Add wireframe helper for better visualization of grid lines
            const wireframeGeo = new THREE.WireframeGeometry(geometry);
            const wireframeMat = new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.3 });
            const wireframe = new THREE.LineSegments(wireframeGeo, wireframeMat);
            mesh.add(wireframe);

            // Rotate mesh so it lays flat on the grid (PlaneGeometry is vertical by default relative to camera)
            // But wait, PlaneGeometry defaults to XY plane. 
            // In Three.js: Y is Up. 
            // We want our Math X and Y to be on the floor (XZ plane in ThreeJS).
            // So we rotate -90 degrees around X axis.
            mesh.rotation.x = -Math.PI / 2;

            scene.add(mesh);
        }

        function updateGraph(type) {
            createGraph(type);
            
            // Update UI Text & Buttons
            const title = document.getElementById('title-text');
            const desc = document.getElementById('desc-text');
            const btns = document.querySelectorAll('button');
            
            btns.forEach(b => b.classList.remove('active'));

            if (type === 'max') {
                title.innerText = "Titik Maksimum";
                desc.innerText = "Kurva melengkung ke BAWAH di semua arah (fxx < 0, fyy < 0).";
                document.getElementById('btn-max').classList.add('active');
            } else if (type === 'min') {
                title.innerText = "Titik Minimum";
                desc.innerText = "Kurva melengkung ke ATAS di semua arah (fxx > 0, fyy > 0).";
                document.getElementById('btn-min').classList.add('active');
            } else {
                title.innerText = "Titik Pelana (Saddle Point)";
                desc.innerText = "Melengkung ke atas di satu sisi, ke bawah di sisi lain (|H| < 0).";
                document.getElementById('btn-saddle').classList.add('active');
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // required if damping or autoRotate
            
            // Optional: Rotate slowly automatically
            if(mesh) {
                mesh.rotation.z += 0.002; // Rotate around the math Z axis (which is mesh local Z, but world Y due to rotation)
            }
            
            renderer.render(scene, camera);
        }

        // Initialize App
        init();

    </script>
</body>
</html>
